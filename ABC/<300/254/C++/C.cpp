#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
#define rep(i, s, t) for(int i = (s); i < (t); ++i)
const int pInf32 =  1000000000+7;

/*
Kind of residue class.(i ~ j := i%K = j%K, S_k = {a_i | i~k and 0 <= k < K}, a_j is fixed to 0-indexed)
if(i  ~ j) -> a_i and a_j can be swapped each other.
if(i !~ j) -> a_i and a_j cannot be swapped by any means.
if a seaquence A = {a_i}_i is sorted -> S_k is, for each k, sorted.
let S_k be sorted for each k, then A after the best effort swap can be generated by
S_0[0], S_1[0], ... , S_{K-1}[0], S_1[0], S_1[1], ... , S_{K-1}[1], ... , S_{K-1}[N/K].
hence if N/K+1 sequences {S_k[0]}_k, {S_k[1]}_k, ... , {S_k[N/K]}_k are sorted and  
S_{K-1}[c-1] <= S_0[c] for each c, A is sorted by the best effort swap.
*/
int main(){
  int N, K; cin >> N >> K;
  // A[k] = S_k, initializes by sufficiently big value.
  vector A(K, vector<int>(N/K+1, pInf32)); rep(i,0,N) cin >> A[i%K][i/K];
  // sort S_k for each k.
  rep(k,0,K) sort(A[k].begin(), A[k].end());

  // check if {S_k[c]}_k is sorted for each 0 <= c <= N/K.
  rep(c,0,N/K+1){
    bool flag_k = true;
    rep(k,1,K) flag_k = flag_k && (A[k][c]>=A[k-1][c]);
    if(!flag_k){cout << "No" << endl; return 0;}
  }
  // check if S_{k-1}[c] <= S_0[c] for each c.
  rep(c,1,N/K+1)if(A[K-1][c-1] > A[0][c]){cout << "No" << endl; return 0;}

  cout << "Yes" << endl;
  return 0;
}